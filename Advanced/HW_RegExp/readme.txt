Slider
	1. HTML/CSS:
	- створюємо контейнер для слайдера з класом .slideWrap
	- задаємо йому відповідну висоту та ширину, а також position absolute top, left, right - 0 відповідно,
	 щоб не зламалась розмітка (для розмітки використовуємо Bootstrap) і він не займав більше рядків ніж потрібно;
	- в контейнері створюємо блок з класом .slider, в якому розміщуються самі картинки/слайди;
	- блоку .slider задаємо ширину, висоту 100% - щоб він прийняв значення батьківського елемента, також задаємо йому
	position relative, так як картинки та стрілочки будуть розміщуватися відносно даного блока;
	- слайдам .sliderImg задаємо висоту 100%, щоб вони зайняли всю висоту батьківського е-та .slider та ширину 300px.
	Розміщуємо слайди по центру - горизонталі, задавши їм position: absolute, left:50%; за допомогою функції transform
	зі значенням translateX(-50%).
	- всім слайдам задаємо display: none;, щоб вони не відображалися;
	- першій картинці присвоюємо клас .current та задаємо display: block;
	- стрілки розміщуємо відносно слайдера за допомогою position: absolute; left,right: 5px відповідно. Центруємо їх по вертикалі
	за допомогою функції transform 	зі значенням translateY(-50%), задавши при цьому значення top 50%;
	- щоб при наведенні на стрілки змінювався колір та знак курсору мишки - використовуємо псевдоклас hover та задаємо
	елементам з класом .arrow(стралки)	background-color: lightgray; cursor: pointer; А також border-radius - 50%, щоб наш
	backround мав круглу форму;

	2. підключаємо бібліотеку JQuery за допомогою CDN
	3. підключаємо js файл script.js.
	4.  JQUERY:
        1) створюємо функцію, за допомогою якої будемо змінювати наші слайди function moveLeft():
        -отримуємо index нашого поточного слайда за допомогою методу index(), зверчаючись до нашого елемента, використовуючи клас
        .current та записуємо значення в змінну currentSlideIndex; (рядок 3)
        - створюємо змінну nextSlideIndex, яка матиме значення currentSlideIndex +1, використовуючи при цьому
        префіксну форму інкремента, щоб одразу використати значення оператора.(рядок 4)
        - створюємо змінну nextSlide - це буде наш слайд, якій відібражатиметься наступним. Використовуємо метод eq() і передаємо
        в нього параметр nextSlideIndex (наша наступна картинка); (рядок5)
        - потімо робимо плавне затухання нашого поточноо слайду за допомогою метода fadeOut, з часом 1 сек. та видаляємо в нього
        клас .current (рядок 6-7)
        - відповідно робимо умову, якщо index наступного сладу дорівнюватиме індексу останнього слайду+1(це озанчатиме,
        що ми дійшли до кінця слайдів), тоді показувати перший слайд. Використовуємо метод fadeIn та додаємо клас .current(9-11)
        В іншому випадку ми просто показуємо наступний слайд (nextSlide.fadeIn)  (12-14)
        2)На праву стрілку (доступаємося до ел-ту за допомогою ID #rightBtn) навішуємо обробник події click і викликаємо
        функцію moveLeft() (рядок 17)
        3) Щоб наш слайдер працював автоматично, використовуємо функцію setInterval(moveLeft(),2000);Так як функція повертає нам
        ідентифікатор інтервалу (interval), ми зможемо його передати в функцію ClearInterval(), щоб зупинити наш слайдер при на
        веденні курсору миши. Обгортаємо все у функцію nextSlide(), щоб не дублювати код для повторного запуску сладеру, при виході
        курсору за його межі. (рядок 19-33);
        4) Пишемо функцію, щоб слайди відображалися в зворотньому порядку function moveRight() та передамо її в обробник подій click(),
        який ми навішуємо на ліву стрілку. Умови писати не потрібно, так як попередній слайд від поточного матиме index -1, що означатиме
        перший слайд зкінця(тобто останній). (35-44)

2. Валідація полів форми.
    1. підключаємо js файл script1.js.
    2. JS:
        1) let params - доступаємося до полів розмірів за допомогою класу .param (рядок 2)
        2) let paramBtn - кнопки з повідомленнями NULL(рядок 3)
        3) let errBtn - кнопки з повідомленнями про помилку в заповненні поля(рядок 4)
        4) циклом for перебираємо всі поля params. В циклі на кожен інпут навішуємо обробник події
            - focus(рядок 7 -9) - при фокусі до кнопки з повідмленням NULL додаємо клас dspNone (в CSS ми зазнаяили стилі для елементів з класом
            dspNone - display: none;). Таким чином повідомлення зникає.
            - blur(рядок 10 -12) - при втраті фокусу, якщо поле не заповнене, тоді клас dspNone видаляємо
            - input(рядок 15-27) -  при введенні отримуємо значення поля і робимо перевірку даних. Створюємо змінну reg, в яку записуємо
            регулярний вираз для валідації. Використовуємо метод test(). якщо він повертає true(тобто якщо значення поля відповідає
            регулярному виразу), до кнопки з повідомленнями про помилку додаємо клас dspNone. В іншому випадку робимо перевірку помилки,
            яка сталася. І записуємо відповідний текст errBtn[i] та видаляємо клас dspNone, таким чином нам відображається повідомлення
            з помилкою.
        5) На інпут з іменем також навішуємо обробники focus (рядок 43-45) та blur(рядок 47-49) та input(рядок 31-39). Той самий підхід, що
        і з params.
        6) Інпут з номером телефону. При фокусі value поля = +38. Робимо перевірку, якщо кількість символів поля = 3, то додаємо дужку.
           Для того щоб додавались розділові знаки при події input робимо відповідні умови - після певної кількості символів додаємо певні
           розділові знаки (рядок 70-77). Валідуємо поле за допомогою регулярного виразу(79-85). Також виключаємо можливість введення будь-яких
           інших символів крім цифер за допомогою регулярного виразу та методу preventDefault(88-99).
        7)На інпути з е-мейлом та зростом навішуємо обробники focus,blur та input(рядок 92-134).
        8) Кнопка OK. По замовчуванню робимо кнопку неактивною. (рядок 137). Для активації пишемо функцію activeOkBtn()(рядок 138-143), в якій робимо перевірку, якщо
        кількість елементів з класом dspNone = 34(тобто всі кнопки з повідмленням про помилку або NULL мають клас dspNone і відповідно
        всі поля заповнені правильно), повертаємо значення getId("okBtn").disabled = false, тобто активуємо кнопку. В іншому випадку - кнопка
        неактиктивна. Функцію activeOkBtn() викликаємо в кожному інпуті після проходження валідації, так як поля можуть заповнюватися в будь якому
        порядку.
        9) На кнопку okBtn навішуємо обробник click, при якому оновлюємо сторінку.(148-149)





